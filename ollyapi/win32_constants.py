#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
#    win32_constants.py - You will find in this file all the Windows structures/define/cst/whatever
#    Copyright (C) 2012 Axel "0vercl0k" Souchet - http://www.twitter.com/0vercl0k
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

from ctypes import *

# from http://www.python-forum.org/pythonforum/viewtopic.php?f=15&t=25087 THX, you saved me a lot of time!
# Constants
DEBUG_PROCESS         = 0x00000001
CREATE_NEW_CONSOLE    = 0x00000010
PROCESS_ALL_ACCESS    = 0x001F0FFF
INFINITE              = 0xFFFFFFFF
DBG_CONTINUE          = 0x00010002

# Debug event constants
EXCEPTION_DEBUG_EVENT      =    0x1
CREATE_THREAD_DEBUG_EVENT  =    0x2
CREATE_PROCESS_DEBUG_EVENT =    0x3
EXIT_THREAD_DEBUG_EVENT    =    0x4
EXIT_PROCESS_DEBUG_EVENT   =    0x5
LOAD_DLL_DEBUG_EVENT       =    0x6
UNLOAD_DLL_DEBUG_EVENT     =    0x7
OUTPUT_DEBUG_STRING_EVENT  =    0x8
RIP_EVENT                  =    0x9

# Debug exception codes.
EXCEPTION_ACCESS_VIOLATION     = 0xC0000005
EXCEPTION_BREAKPOINT           = 0x80000003
EXCEPTION_GUARD_PAGE           = 0x80000001
EXCEPTION_SINGLE_STEP          = 0x80000004

# Hardware breakpoint conditions
HW_ACCESS                      = 0x00000003
HW_EXECUTE                     = 0x00000000
HW_WRITE                       = 0x00000001

class EXCEPTION_RECORD(Structure):
    """Describes an exception."""
    pass
    
EXCEPTION_RECORD._fields_ = [
    # The reason the exception occurred.
    # This is the code generated by a hardware exception, or the code specified in the RaiseException function for a software-generated exception.
    # The following tables describes the exception codes that are likely to occur due to common programming errors.
    ('ExceptionCode', c_ulong),

    # The exception flags.
    # This member can be either zero, indicating a continuable exception, or EXCEPTION_NONCONTINUABLE indicating a noncontinuable exception.
    # Any attempt to continue execution after a noncontinuable exception causes the EXCEPTION_NONCONTINUABLE_EXCEPTION exception.
    ('ExceptionFlags', c_ulong),

    # A pointer to an associated EXCEPTION_RECORD structure.
    # Exception records can be chained together to provide additional information when nested exceptions occur.
    ('ExceptionRecord', POINTER(EXCEPTION_RECORD)),

    # The address where the exception occurred.
    ('ExceptionAddress', c_ulong),

    # The number of parameters associated with the exception.
    # This is the number of defined elements in the ExceptionInformation array.
    ('NumberParameters', c_ulong),

    # An array of additional arguments that describe the exception.
    # The RaiseException function can specify this array of arguments.
    # For most exception codes, the array elements are undefined.
    # The following table describes the exception codes whose array elements are defined.
    ('ExceptionInformation', POINTER(c_ulong) * 15),
]

class EXCEPTION_DEBUG_INFO(Structure):
    """Contains exception information that can be used by a debugger."""
    _fields_ = [
        # An EXCEPTION_RECORD structure with information specific to the exception.
        # This includes the exception code, flags, address, a pointer to a related exception, extra parameters, and so on.
        ('ExceptionRecord', EXCEPTION_RECORD),

        # A value that indicates whether the debugger has previously encountered the exception specified by the ExceptionRecord member.
        # If the dwFirstChance member is nonzero, this is the first time the debugger has encountered the exception.
        # Debuggers typically handle breakpoint and single-step exceptions when they are first encountered.
        # If this member is zero, the debugger has previously encountered the exception.
        # This occurs only if, during the search for structured exception handlers, either no handler was found or the exception was continued.
        ('dwFirstChance', c_ulong),
    ]

class CREATE_THREAD_DEBUG_INFO(Structure):
    """Contains thread-creation information that can be used by a debugger."""
    _fields_ = [
        # A handle to the thread whose creation caused the debugging event.
        # If this member is NULL, the handle is not valid.
        # Otherwise, the debugger has THREAD_GET_CONTEXT, THREAD_SET_CONTEXT, and THREAD_SUSPEND_RESUME access to the thread,
        # allowing the debugger to read from and write to the registers of the thread and control execution of the thread.
        ('hThread', c_void_p),

        # A pointer to a block of data.
        # At offset 0x2C into this block is another pointer, called ThreadLocalStoragePointer,
        # that points to an array of per-module thread local storage blocks.
        # This gives a debugger access to per-thread data in the threads of the process being
        # debugged using the same algorithms that a compiler would use.
        ('lpThreadLocalBase', c_void_p),

        # A pointer to the starting address of the thread.
        # This value may only be an approximation of the thread's starting address,
        # because any application with appropriate access to the thread can change the thread's
        # context by using the SetThreadContext function.
        ('lpStartAddress', c_ulong)
    ]

class CREATE_PROCESS_DEBUG_INFO(Structure):
    """Contains process creation information that can be used by a debugger."""
    _fields_ = [
        # A handle to the process's image file.
        # If this member is NULL, the handle is not valid.
        # Otherwise, the debugger can use the member to read from and write to the image file.
        ('hFile', c_void_p),

        # A handle to the process.
        # If this member is NULL, the handle is not valid. Otherwise,
        # the debugger can use the member to read from and write to the process's memory.
        ('hProcess', c_void_p),

        # A handle to the initial thread of the process identified by the hProcess member.
        # If hThread param is NULL, the handle is not valid.
        # Otherwise, the debugger has THREAD_GET_CONTEXT, THREAD_SET_CONTEXT, and THREAD_SUSPEND_RESUME access
        # to the thread, allowing the debugger to read from and write to the registers of
        # the thread and to control execution of the thread.
        ('hThread', c_void_p),

        # The base address of the executable image that the process is running.
        ('lpBaseOfImage', c_void_p),

        # The offset to the debugging information in the file identified by the hFile member.
        ('dwDebugInfoFileOffset', c_ulong),

        # The size of the debugging information in the file, in bytes. If this value is zero, there is no debugging information.
        ('nDebugInfoSize', c_ulong),

        # A pointer to a block of data.
        # At offset 0x2C into this block is another pointer, called ThreadLocalStoragePointer,
        # that points to an array of per-module thread local storage blocks. This gives a debugger
        # access to per-thread data in the threads of the process being debugged using the same algorithms that a compiler would use.
        ('lpThreadLocalBase', c_void_p),

        # A pointer to the starting address of the thread.
        # This value may only be an approximation of the thread's starting address,
        # because any application with appropriate access to the thread can change the
        # thread's context by using the SetThreadContext function.
        ('lpStartAddress', c_ulong),

        # A pointer to the file name associated with the hFile member.
        # This parameter may be NULL, or it may contain the address of a string pointer
        # in the address space of the process being debugged.
        # That address may, in turn, either be NULL or point to the actual filename.
        # If fUnicode is a nonzero value, the name string is Unicode; otherwise, it is ANSI.
        # This member is strictly optional.
        # Debuggers must be prepared to handle the case where lpImageName is NULL or *lpImageName (in the address space of the process being debugged) is NULL.
        # Specifically, the system does not provide an image name for a create process event,
        # and will not likely pass an image name for the first DLL event.
        # The system also does not provide this information in the case of debug events that originate
        # from a call to the DebugActiveProcess function.
        ('lpImageName', c_void_p),

        # A value that indicates whether a file name specified by the lpImageName member is Unicode or ANSI.
        # A nonzero value indicates Unicode; zero indicates ANSI.
        ('fUnicode', c_ushort)
    ]

class EXIT_THREAD_DEBUG_INFO(Structure):
    """Contains the exit code for a terminating thread."""
    _fields_ = [
        # The exit code for the thread.
        ('dwExitCode', c_ulong)
    ]

class EXIT_PROCESS_DEBUG_INFO(Structure):
    """The exit code for the process."""
    _fields_ = [
        # The exit code for the process.
        ('dwExitCode', c_ulong)
    ]

class LOAD_DLL_DEBUG_INFO(Structure):
    """Contains information about a dynamic-link library (DLL) that has just been loaded."""
    _fields_ = [
        # A handle to the loaded DLL.
        # If this member is NULL, the handle is not valid.
        # Otherwise, the member is opened for reading and read-sharing in the context of the debugger.
        ('hFile', c_void_p),

        # A pointer to the base address of the DLL in the address space of the process loading the DLL.
        ('lpBaseOfDll', c_ulong),

        # The offset to the debugging information in the file identified by the hFile member, in bytes.
        # The system expects the debugging information to be in CodeView 4.0 format.
        # This format is currently a derivative of Common Object File Format (COFF).
        ('dwDebugInfoFileOffset', c_ulong),

        # The size of the debugging information in the file, in bytes. If this member is zero, there is no debugging information.
        ('nDebugInfoSize', c_ulong),

        # A pointer to the file name associated with hFile.
        # This member may be NULL, or it may contain the address of a string pointer
        # in the address space of the process being debugged.
        # That address may, in turn, either be NULL or point to the actual filename.
        # If fUnicode is a nonzero value, the name string is Unicode; otherwise, it is ANSI.
        # This member is strictly optional.
        # Debuggers must be prepared to handle the case where lpImageName is NULL or *lpImageName (in the address space of the process being debugged) is NULL.
        # Specifically, the system will never provide an image name for a create process event,
        # and it will not likely pass an image name for the first DLL event.
        # The system will also never provide this information in the case of debugging events that originate from a call to the DebugActiveProcess function.
        ('lpImageName', c_void_p),

        # A value that indicates whether a filename specified by lpImageName is Unicode or ANSI.
        # A nonzero value for this member indicates Unicode; zero indicates ANSI.
        ('fUnicode', c_ushort)
    ]

class UNLOAD_DLL_DEBUG_INFO(Structure):
    """Contains information about a dynamic-link library (DLL) that has just been unloaded."""
    _fields_ = [
        # A pointer to the base address of the DLL in the address space of the process unloading the DLL.
        ('lpBaseOfDll', c_ulong)
    ]

class OUTPUT_DEBUG_STRING_INFO(Structure):
    """Contains the address, format, and length, in bytes, of a debugging string."""
    _fields_ = [
        # The debugging string in the calling process's address space.
        # The debugger can use the ReadProcessMemory function to retrieve the value of the string.
        ('lpDebugStringData', c_char_p),

        # The format of the debugging string. If this member is zero, the debugging string is ANSI; if it is nonzero, the string is Unicode.
        ('fUnicode', c_ushort),

        # The size of the debugging string, in characters. The length includes the string's terminating null character.
        ('nDebugStringLength', c_ushort)
    ]

class RIP_INFO(Structure):
    """Contains the error that caused the RIP debug event."""
    _fields_ = [
        # The error that caused the RIP debug event.
        # For more information, see Error Handling.
        ('dwError', c_ulong),

        # Any additional information about the type of error that caused the RIP debug event.
        # This member can be one of the following values.
        ('dwType', c_ulong)
    ]

class DEBUG_EVENT_UNION(Union):
    """Describes a debugging event."""
    _fields_ = [
        ('Exception', EXCEPTION_DEBUG_INFO),
        ('CreateThread', CREATE_THREAD_DEBUG_INFO),
        ('CreateProcessInfo', CREATE_PROCESS_DEBUG_INFO),
        ('ExitThread', EXIT_THREAD_DEBUG_INFO),
        ('ExitProcess', EXIT_PROCESS_DEBUG_INFO),
        ('LoadDll', LOAD_DLL_DEBUG_INFO),
        ('UnloadDll', UNLOAD_DLL_DEBUG_INFO),
        ('DebugString', OUTPUT_DEBUG_STRING_INFO),
        ('RipInfo', RIP_INFO),
    ]   

class DEBUG_EVENT(Structure):
    """Describes a debugging event."""
    _fields_ = [
        ('dwDebugEventCode', c_ulong),
        ('dwProcessId', c_ulong),
        ('dwThreadId', c_ulong),
        ('u', DEBUG_EVENT_UNION)
    ]